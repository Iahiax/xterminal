<!DOCTYPE html>
<html lang="ar">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>macOS Web Terminal - iOS</title>
    <script src="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.3.0/lib/xterm.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/@xterm/xterm@5.3.0/css/xterm.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.7.0/lib/xterm-addon-fit.min.js"></script>
    <style>
        * {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            touch-action: manipulation;
        }
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            background: #000;
            color: #0f0;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        }
        #terminal-container {
            position: fixed;
            top: 30px;
            left: 0;
            right: 0;
            bottom: 60px;
            padding: 10px;
            box-sizing: border-box;
        }
        #terminal {
            width: 100%;
            height: 100%;
        }
        #ios-keyboard {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: #111;
            border-top: 1px solid #0f0;
            display: flex;
            padding: 5px;
            box-sizing: border-box;
        }
        .key {
            flex: 1;
            margin: 2px;
            background: #222;
            color: #0f0;
            border: 1px solid #0f0;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
        }
        #status-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 30px;
            background: rgba(0, 50, 0, 0.8);
            color: #0f0;
            padding: 0 10px;
            font-size: 14px;
            display: flex;
            align-items: center;
            z-index: 100;
        }
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: #0f0;
        }
        #loading-spinner {
            border: 5px solid #0a0;
            border-top: 5px solid #0f0;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        #loading-message {
            margin-top: 20px;
            text-align: center;
            padding: 0 20px;
        }
        #progress-bar {
            width: 300px;
            height: 20px;
            background: #222;
            margin-top: 20px;
            border-radius: 10px;
            overflow: hidden;
        }
        #progress-fill {
            height: 100%;
            width: 0%;
            background: #0f0;
            transition: width 0.3s;
        }
        #progress-text {
            margin-top: 10px;
        }
        .command-list {
            position: absolute;
            top: 40px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #0f0;
            padding: 10px;
            border-radius: 5px;
            max-width: 300px;
            display: none;
            z-index: 100;
            color: #0f0;
            font-family: monospace;
        }
        .command-list.show {
            display: block;
        }
        .command-list ul {
            padding-left: 20px;
            margin: 10px 0;
        }
        .command-list li {
            margin-bottom: 8px;
        }
        #help-btn {
            position: absolute;
            top: 35px;
            right: 10px;
            background: #002200;
            color: #0f0;
            border: 1px solid #0f0;
            border-radius: 4px;
            padding: 5px 10px;
            cursor: pointer;
            z-index: 101;
        }
    </style>
</head>
<body>
    <div id="loading-overlay">
        <div id="loading-spinner"></div>
        <div id="loading-message">Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªÙ‡ÙŠØ¦Ø©ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±... Ù‚Ø¯ ÙŠØ³ØªØºØ±Ù‚ Ù‡Ø°Ø§ Ø¨Ø¶Ø¹ Ø¯Ù‚Ø§Ø¦Ù‚</div>
        <div id="progress-bar">
            <div id="progress-fill"></div>
        </div>
        <div id="progress-text">0%</div>
    </div>
    
    <div id="status-bar">Ø§Ù„Ø­Ø§Ù„Ø©: Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªÙ‡ÙŠØ¦Ø©...</div>
    
    <button id="help-btn">Ù…Ø³Ø§Ø¹Ø¯Ø©</button>
    <div id="command-list" class="command-list">
        <h3 style="margin-top:0">Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£ÙˆØ§Ù…Ø±:</h3>
        <ul>
            <li><code>start-macos</code>: Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ macOS</li>
            <li><code>stop-macos</code>: Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù†Ø¸Ø§Ù…</li>
            <li><code>restart-macos</code>: Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ´ØºÙŠÙ„</li>
            <li><code>install-python-git</code>: ØªØ«Ø¨ÙŠØª Python Ùˆ Git</li>
            <li><code>run-install-script</code>: ØªØ´ØºÙŠÙ„ Ø³ÙƒØ±ÙŠØ¨Øª Ø§Ù„ØªØ«Ø¨ÙŠØª</li>
            <li><code>set-ram [Ø­Ø¬Ù…]</code>: ØªØºÙŠÙŠØ± Ø­Ø¬Ù… Ø§Ù„Ø°Ø§ÙƒØ±Ø© (MB)</li>
            <li><code>create-snapshot</code>: Ø¥Ù†Ø´Ø§Ø¡ Ù„Ù‚Ø·Ø© Ù„Ù„Ù†Ø¸Ø§Ù…</li>
            <li><code>restore-snapshot</code>: Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ù„Ù‚Ø·Ø©</li>
            <li><code>list-snapshots</code>: Ø¹Ø±Ø¶ Ø§Ù„Ù„Ù‚Ø·Ø§Øª Ø§Ù„Ù…Ø­ÙÙˆØ¸Ø©</li>
            <li><code>set-resolution [w]x[h]</code>: ØªØºÙŠÙŠØ± Ø¯Ù‚Ø© Ø§Ù„Ø´Ø§Ø´Ø©</li>
            <li><code>help</code>: Ø¹Ø±Ø¶ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£ÙˆØ§Ù…Ø±</li>
            <li><code>Ctrl+L</code>: Ù…Ø³Ø­ Ø§Ù„Ø´Ø§Ø´Ø©</li>
            <li><code>neofetch</code>: Ø¹Ø±Ø¶ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù…</li>
            <li><code>htop</code>: Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª</li>
        </ul>
    </div>
    
    <div id="terminal-container">
        <div id="terminal"></div>
    </div>
    
    <div id="ios-keyboard">
        <div class="key" data-key="Tab">Tab</div>
        <div class="key" data-key="Ctrl">Ctrl</div>
        <div class="key" data-key="Alt">Alt</div>
        <div class="key" data-key="â†‘">â†‘</div>
        <div class="key" data-key="â†“">â†“</div>
        <div class="key" data-key="â†">â†</div>
        <div class="key" data-key="â†’">â†’</div>
        <div class="key" data-key="Enter">Enter</div>
    </div>

    <script>
        // ===== Ø­Ù„ÙˆÙ„ ØªÙˆØ§ÙÙ‚ Ù…Ø¹ iOS =====
        (function() {
            if (!window.WebAssembly) {
                alert('Ø§Ù„Ù…ØªØµÙØ­ Ù„Ø§ ÙŠØ¯Ø¹Ù… WebAssembly! ÙŠØ±Ø¬Ù‰ Ø§Ø³ØªØ®Ø¯Ø§Ù… Safari 15+ Ø£Ùˆ Chrome 85+');
            }

            if (!window.Worker) {
                alert('Ø§Ù„Ù…ØªØµÙØ­ Ù„Ø§ ÙŠØ¯Ø¹Ù… Web Workers! ÙŠØ±Ø¬Ù‰ ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…ØªØµÙØ­');
            }

            window.addEventListener('load', () => {
                if (/iP(ad|hone|od)/i.test(navigator.userAgent)) {
                    document.body.style.webkitTransform = 'translate3d(0,0,0)';
                    document.body.style.overflow = 'hidden';
                }
            });

            document.addEventListener('touchmove', (e) => {
                if(e.scale !== 1) {
                    e.preventDefault();
                }
            }, { passive: false });

            if (navigator.deviceMemory < 4) {
                alert('Ø§Ù„Ø¬Ù‡Ø§Ø² Ù„Ø¯ÙŠÙ‡ Ø°Ø§ÙƒØ±Ø© ÙˆØµÙˆÙ„ Ø¹Ø´ÙˆØ§Ø¦ÙŠ (RAM) Ù…Ù†Ø®ÙØ¶Ø©. Ù‚Ø¯ Ù„Ø§ ÙŠØ¹Ù…Ù„ Ø§Ù„Ù†Ø¸Ø§Ù… Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­.');
            }

            WebAssembly.instantiateStreaming = async (response, importObject) => {
                if (typeof response === 'function') {
                    return WebAssembly.instantiate(response(), importObject);
                }
                return WebAssembly.instantiate(await response, importObject);
            };

            if (!window.requestIdleCallback) {
                window.requestIdleCallback = (callback) => {
                    return setTimeout(() => {
                        callback({
                            didTimeout: false,
                            timeRemaining: () => 50
                        });
                    }, 1);
                };
                window.cancelIdleCallback = (id) => clearTimeout(id);
            }
        })();

        // ===== Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù… Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© =====
        const CONFIG = {
            RAM_SIZE: 4096, // 4GB Ù„Ù„ØªÙˆØ§ÙÙ‚ Ù…Ø¹ iOS
            CPU_CORES: 2,   // Ù†ÙˆØ§ØªÙŠÙ† Ù„Ù„ØªÙˆØ§ÙÙ‚
            AUTO_SAVE_INTERVAL: 300000,
            PERSISTENCE_KEY: 'macos-kvm-ios',
            DEBUG_MODE: true,
            KERNEL_URL: 'https://archive.org/download/minimal-linux-kernel/minimal-kernel-5.10.iso'
        };

        // ===== ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ØªÙŠØ±Ù…ÙŠÙ†Ø§Ù„ =====
        const term = new Terminal({
            fontSize: 14,
            fontFamily: 'Menlo, monospace',
            cursorBlink: true,
            theme: {
                background: '#001100',
                foreground: '#00ff00'
            },
            allowProposedApi: true
        });
        
        const fitAddon = new FitAddon.FitAddon();
        term.loadAddon(fitAddon);
        term.open(document.getElementById('terminal'));
        
        // ===== Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù†Ø¸Ø§Ù… =====
        let driveHandle;
        let dockerWorker;
        let kvmWorker;
        let resourceInterval;
        let isSystemReady = false;

        // ===== Ù†Ø¸Ø§Ù… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø£Ø®Ø·Ø§Ø¡ =====
        const debugLog = (message, type = 'info') => {
            const colors = {
                info: '\x1b[36m',
                success: '\x1b[32m',
                warning: '\x1b[33m',
                error: '\x1b[31m',
                debug: '\x1b[35m'
            };
            const reset = '\x1b[0m';
            const timestamp = new Date().toLocaleTimeString();
            
            if (CONFIG.DEBUG_MODE || type === 'error') {
                term.writeln(`${colors[type]}[${timestamp}] ${message}${reset}`);
            }
            
            if (type === 'error') {
                console.error(`[${timestamp}] ${message}`);
            }
        };

        // ===== ÙˆØ¸Ø§Ø¦Ù Ù…Ø³Ø§Ø¹Ø¯Ø© =====
        function updateStatus(message) {
            document.getElementById('status-bar').innerText = `Ø§Ù„Ø­Ø§Ù„Ø©: ${message}`;
        }

        function updateProgress(percent) {
            document.getElementById('progress-fill').style.width = `${percent}%`;
            document.getElementById('progress-text').innerText = `${percent}%`;
        }

        function hideLoadingOverlay() {
            document.getElementById('loading-overlay').style.display = 'none';
        }

        function showLoadingMessage(message) {
            document.getElementById('loading-message').innerText = message;
        }

        function setupIOSKeyboard() {
            document.querySelectorAll('.key').forEach(key => {
                key.addEventListener('click', () => {
                    if (!isSystemReady) return;
                    
                    const keyValue = key.getAttribute('data-key');
                    switch(keyValue) {
                        case 'Tab': term.write('\t'); break;
                        case 'Ctrl': term.write('\x11'); break;
                        case 'Alt': term.write('\x12'); break;
                        case 'â†‘': term.write('\x1b[A'); break;
                        case 'â†“': term.write('\x1b[B'); break;
                        case 'â†': term.write('\x1b[D'); break;
                        case 'â†’': term.write('\x1b[C'); break;
                        case 'Enter': term.write('\r'); break;
                    }
                });
            });
        }

        function toggleCommandList() {
            const list = document.getElementById('command-list');
            list.classList.toggle('show');
        }

        // ===== ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù†ÙˆØ§Ø© =====
        async function loadKernel(url, progressCallback) {
            return new Promise(async (resolve, reject) => {
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`ÙØ´Ù„ Ø§Ù„ØªØ­Ù…ÙŠÙ„: ${response.status} ${response.statusText}`);
                    }
                    
                    const contentLength = +response.headers.get('Content-Length');
                    const reader = response.body.getReader();
                    let receivedLength = 0;
                    let chunks = [];
                    
                    while(true) {
                        const {done, value} = await reader.read();
                        
                        if (done) break;
                        
                        chunks.push(value);
                        receivedLength += value.length;
                        
                        if (contentLength) {
                            const percent = Math.round((receivedLength / contentLength) * 100);
                            progressCallback(percent);
                        }
                    }
                    
                    let chunksAll = new Uint8Array(receivedLength);
                    let position = 0;
                    for(let chunk of chunks) {
                        chunksAll.set(chunk, position);
                        position += chunk.length;
                    }
                    
                    resolve(chunksAll);
                } catch (error) {
                    reject(error);
                }
            });
        }

        // ===== ÙƒÙˆØ¯ KVM Worker =====
        function createKVMWorker() {
            const kvmWorkerCode = `
                self.importScripts('https://cdn.jsdelivr.net/npm/kvm-wasm@1.3.0/dist/kvm.ios.min.js');
                
                class KVMManager {
                    constructor() {
                        this.kvm = null;
                        this.snapshots = [];
                    }
                
                    async init(config) {
                        try {
                            self.postMessage({ type: 'status', message: 'Ø¬Ø§Ø±ÙŠ ØªÙ‡ÙŠØ¦Ø© KVM Ù…Ø¹ Ø§Ù„Ù†ÙˆØ§Ø©...' });
                            
                            this.kvm = new KVMWASM({
                                memory: config.memory,
                                cores: config.cores,
                                drive: config.drive,
                                kernel: config.kernel,
                                iosCompat: true
                            });
                
                            await this.kvm.configure({
                                cpu: {
                                    model: 'penryn',
                                    features: 'kvm=on,+ssse3,+sse4.2,+popcnt,+avx,+aes,+xsave,+xsaveopt'
                                },
                                memory: {
                                    size: config.memory,
                                    slots: 2
                                },
                                boot: {
                                    loader: 'grub',
                                    kernelParams: 'console=ttyS0 root=/dev/vda1'
                                }
                            });
                
                            self.postMessage({ type: 'status', message: 'KVM Ø¬Ø§Ù‡Ø²' });
                            self.postMessage({ type: 'kvm-ready' });
                        } catch (error) {
                            self.postMessage({ type: 'error', message: \`KVM Init Error: \${error.message}\` });
                        }
                    }
                
                    async createSnapshot(name) {
                        try {
                            const snapshot = await this.kvm.createSnapshot();
                            this.snapshots.push({ name, date: new Date(), data: snapshot });
                            self.postMessage({ type: 'snapshot-created', name });
                        } catch (error) {
                            self.postMessage({ type: 'error', message: \`Snapshot Error: \${error.message}\` });
                        }
                    }
                
                    async restoreSnapshot(name) {
                        try {
                            const snapshot = name === 'latest' 
                                ? this.snapshots[this.snapshots.length - 1]
                                : this.snapshots.find(s => s.name === name);
                            
                            if (!snapshot) throw new Error('Ø§Ù„Ù„Ù‚Ø·Ø© ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø©');
                            
                            await this.kvm.restoreSnapshot(snapshot.data);
                            self.postMessage({ type: 'snapshot-restored', name: snapshot.name });
                        } catch (error) {
                            self.postMessage({ type: 'error', message: \`Restore Error: \${error.message}\` });
                        }
                    }
                
                    async setMemory(size) {
                        try {
                            if (size < 4096 || size > 16384) {
                                throw new Error('Ø§Ù„Ø­Ø¬Ù… ØºÙŠØ± ØµØ­ÙŠØ­ (4096-16384)');
                            }
                            
                            await this.kvm.setMemorySize(size);
                            self.postMessage({ type: 'status', message: \`ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø¥Ù„Ù‰ \${size}MB\` });
                        } catch (error) {
                            self.postMessage({ type: 'error', message: \`Set Memory Error: \${error.message}\` });
                        }
                    }
                
                    async getResources() {
                        try {
                            if (this.kvm) {
                                const resources = await this.kvm.getSystemResources();
                                self.postMessage({ type: 'resources', ram: resources.memory.used, cpu: resources.cpu.usage });
                            }
                        } catch (error) {
                            console.error('Resource monitoring error:', error);
                        }
                    }
                
                    listSnapshots() {
                        self.postMessage({ type: 'snapshot-list', snapshots: this.snapshots });
                    }
                }
                
                const kvmManager = new KVMManager();
                
                self.onmessage = async (e) => {
                    try {
                        switch (e.data.type) {
                            case 'init':
                                await kvmManager.init(e.data.config);
                                break;
                            case 'snapshot':
                                await kvmManager.createSnapshot(e.data.name);
                                break;
                            case 'restore':
                                await kvmManager.restoreSnapshot(e.data.name);
                                break;
                            case 'set-ram':
                                await kvmManager.setMemory(e.data.ram);
                                break;
                            case 'get-resources':
                                await kvmManager.getResources();
                                break;
                            case 'list-snapshots':
                                kvmManager.listSnapshots();
                                break;
                            default:
                                self.postMessage({ type: 'error', message: \`Unknown command: \${e.data.type}\` });
                        }
                    } catch (error) {
                        self.postMessage({ type: 'error', message: \`Worker Error: \${error.message}\` });
                    }
                };
            `;
            
            const blob = new Blob([kvmWorkerCode], { type: 'application/javascript' });
            return new Worker(URL.createObjectURL(blob));
        }

        // ===== ÙƒÙˆØ¯ Docker Worker =====
        function createDockerWorker() {
            const dockerWorkerCode = `
                self.importScripts('https://cdn.jsdelivr.net/npm/docker-wasm@0.5.0/dist/docker.ios.min.js');
                
                class DockerManager {
                    constructor() {
                        this.docker = null;
                        this.containerId = null;
                    }
                
                    async init(config) {
                        try {
                            self.postMessage({ type: 'status', message: 'Ø¬Ø§Ø±ÙŠ ØªÙ‡ÙŠØ¦Ø© Docker...' });
                            
                            this.docker = new DockerWASM({
                                resourceLimits: {
                                    memory: 4096,
                                    cpuQuota: 50000
                                },
                                volumes: config.volumes,
                                iosCompat: true
                            });
                
                            self.postMessage({ type: 'docker-ready' });
                        } catch (error) {
                            self.postMessage({ type: 'error', message: \`Docker Init Error: \${error.message}\` });
                        }
                    }
                
                    async runContainer(containerConfig) {
                        try {
                            self.postMessage({ type: 'status', message: 'Ø¬Ø§Ø±ÙŠ ØªØ´ØºÙŠÙ„ macOS...' });
                            
                            const modifiedConfig = {
                                ...containerConfig,
                                options: {
                                    ...containerConfig.options,
                                    kernel: {
                                        image: containerConfig.env.KERNEL_IMAGE,
                                        bootloader: containerConfig.env.BOOT_LOADER,
                                        params: containerConfig.env.KERNEL_PARAMS
                                    }
                                }
                            };
                            
                            const output = await this.docker.runContainer(modifiedConfig);
                            this.containerId = output.containerId;
                            
                            self.postMessage({ type: 'output', content: output.logs });
                            self.postMessage({ type: 'status', message: 'macOS ÙŠØ¹Ù…Ù„ Ø§Ù„Ø¢Ù†' });
                            
                            try {
                                await this.docker.execCommand(this.containerId, 'chmod +x /install_essentials.sh');
                                const installOutput = await this.docker.execCommand(this.containerId, '/install_essentials.sh');
                                self.postMessage({ type: 'output', content: installOutput });
                                
                                if (installOutput.includes('Python')) {
                                    self.postMessage({ type: 'python-installed' });
                                }
                                if (installOutput.includes('Git')) {
                                    self.postMessage({ type: 'git-installed' });
                                }
                            } catch (installError) {
                                self.postMessage({ type: 'error', message: \`Install Error: \${installError.message}\` });
                            }
                        } catch (error) {
                            self.postMessage({ type: 'error', message: \`Run Error: \${error.message}\` });
                        }
                    }
                
                    async handleInput(data) {
                        if (!this.containerId) return;
                        await this.docker.sendInput(this.containerId, data);
                    }
                
                    async stopContainer() {
                        if (!this.containerId) return;
                        await this.docker.stopContainer(this.containerId);
                        self.postMessage({ type: 'status', message: 'ØªÙ… Ø¥ÙŠÙ‚Ø§Ù macOS' });
                    }
                
                    async restartContainer() {
                        if (!this.containerId) return;
                        await this.docker.restartContainer(this.containerId);
                        self.postMessage({ type: 'status', message: 'Ø¬Ø§Ø±ÙŠ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ´ØºÙŠÙ„' });
                    }
                
                    async runCommand(command) {
                        if (!this.containerId) return;
                        const output = await this.docker.execCommand(this.containerId, command);
                        self.postMessage({ type: 'output', content: output });
                    }
                }
                
                const dockerManager = new DockerManager();
                
                self.onmessage = async (e) => {
                    try {
                        switch (e.data.type) {
                            case 'init':
                                await dockerManager.init(e.data.config);
                                break;
                            case 'run':
                                await dockerManager.runContainer(e.data.container);
                                break;
                            case 'input':
                                await dockerManager.handleInput(e.data.data);
                                break;
                            case 'stop':
                                await dockerManager.stopContainer();
                                break;
                            case 'restart':
                                await dockerManager.restartContainer();
                                break;
                            case 'run-command':
                                await dockerManager.runCommand(e.data.command);
                                break;
                            default:
                                self.postMessage({ type: 'error', message: \`Unknown command: \${e.data.type}\` });
                        }
                    } catch (error) {
                        self.postMessage({ type: 'error', message: \`Worker Error: \${error.message}\` });
                    }
                };
            `;
            
            const blob = new Blob([dockerWorkerCode], { type: 'application/javascript' });
            return new Worker(URL.createObjectURL(blob));
        }

        // ===== Ø§ØªØµØ§Ù„ Google Drive =====
        async function connectGoogleDrive() {
            try {
                debugLog('ğŸŒ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø¬ÙˆØ¬Ù„ Ø¯Ø±Ø§ÙŠÙ...', 'info');
                showLoadingMessage('Ø¬Ø§Ø±ÙŠ Ø·Ù„Ø¨ Ø¥Ø°Ù† Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Google Drive...');
                
                if (!window.showDirectoryPicker) {
                    throw new Error('Ø§Ù„Ù…ØªØµÙØ­ Ù„Ø§ ÙŠØ¯Ø¹Ù… ÙˆØ§Ø¬Ù‡Ø© Ù†Ø¸Ø§Ù… Ø§Ù„Ù…Ù„ÙØ§Øª');
                }
                
                driveHandle = await window.showDirectoryPicker();
                const root = await driveHandle.resolve();
                
                const folders = ['macos_data', 'docker_config', 'system_files', 'snapshots'];
                for (const folder of folders) {
                    try {
                        await root.getDirectoryHandle(folder, { create: true });
                        debugLog(`ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¬Ù„Ø¯: ${folder}`, 'success');
                    } catch (error) {
                        debugLog(`Ø®Ø·Ø£ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ù…Ø¬Ù„Ø¯ ${folder}: ${error.message}`, 'warning');
                    }
                }
                
                debugLog('âœ… ØªÙ… Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø¬ÙˆØ¬Ù„ Ø¯Ø±Ø§ÙŠÙ Ø¨Ù†Ø¬Ø§Ø­!', 'success');
                updateStatus('Ù…ØªØµÙ€Ù„ Ø¨Ø¬ÙˆØ¬Ù„ Ø¯Ø±Ø§ÙŠÙ');
                return true;
            } catch (error) {
                debugLog(`âŒ ÙØ´Ù„ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø¬ÙˆØ¬Ù„ Ø¯Ø±Ø§ÙŠÙ: ${error.message}`, 'error');
                updateStatus('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„');
                return false;
            }
        }

        // ===== ØªØ­Ù…ÙŠÙ„ Linux Kernel ISO =====
        async function loadLinuxKernel() {
            try {
                debugLog('Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Linux Kernel ISO...', 'info');
                showLoadingMessage('Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ù†ÙˆØ§Ø© Ø§Ù„Ù†Ø¸Ø§Ù… (100MB)...');
                
                const kernelData = await loadKernel(CONFIG.KERNEL_URL, updateProgress);
                
                const root = await driveHandle.resolve();
                const fileHandle = await root.getFileHandle('linux-kernel.iso', { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(kernelData);
                await writable.close();
                
                debugLog('âœ… ØªÙ… ØªØ­Ù…ÙŠÙ„ Linux Kernel ISO Ø¨Ù†Ø¬Ø§Ø­!', 'success');
                return true;
            } catch (error) {
                debugLog(`âŒ ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Linux Kernel: ${error.message}`, 'error');
                showLoadingMessage(`Ø®Ø·Ø£: ${error.message}`);
                return false;
            }
        }

        // ===== Ø¥Ø¹Ø¯Ø§Ø¯ KVM =====
        async function setupKVM() {
            try {
                debugLog('âš™ï¸ Ø¬Ø§Ø±ÙŠ ØªÙ‡ÙŠØ¦Ø© KVM...', 'info');
                showLoadingMessage('Ø¬Ø§Ø±ÙŠ ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©...');
                
                kvmWorker = createKVMWorker();
                
                kvmWorker.onmessage = (e) => {
                    if (e.data.type === 'output') {
                        term.write(e.data.content);
                    } else if (e.data.type === 'status') {
                        updateStatus(e.data.message);
                    } else if (e.data.type === 'error') {
                        debugLog(`âŒ ${e.data.message}`, 'error');
                    } else if (e.data.type === 'kvm-ready') {
                        debugLog('âœ… KVM Ø¬Ø§Ù‡Ø² Ù„ØªØ´ØºÙŠÙ„ macOS!', 'success');
                        setupDocker();
                    } else if (e.data.type === 'resources') {
                        updateResources(e.data.ram, e.data.cpu);
                    } else if (e.data.type === 'snapshot-created') {
                        term.writeln(`\x1b[32mâœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù„Ù‚Ø·Ø©: ${e.data.name}\x1b[0m`);
                    } else if (e.data.type === 'snapshot-restored') {
                        term.writeln(`\x1b[32mâœ… ØªÙ… Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ù„Ù‚Ø·Ø©: ${e.data.name}\x1b[0m`);
                    } else if (e.data.type === 'snapshot-list') {
                        term.writeln('\x1b[33mğŸ“‹ Ø§Ù„Ù„Ù‚Ø·Ø§Øª Ø§Ù„Ù…ØªØ§Ø­Ø©:\x1b[0m');
                        e.data.snapshots.forEach(snap => {
                            term.writeln(`- ${snap.name} (${new Date(snap.date).toLocaleString()})`);
                        });
                    }
                };
                
                kvmWorker.postMessage({
                    type: 'init',
                    config: {
                        memory: CONFIG.RAM_SIZE,
                        cores: CONFIG.CPU_CORES,
                        drive: 'macos_data',
                        kernel: 'linux-kernel.iso'
                    }
                });
                
                return true;
            } catch (error) {
                debugLog(`âŒ ÙØ´Ù„ ØªÙ‡ÙŠØ¦Ø© KVM: ${error.message}`, 'error');
                return false;
            }
        }

        // ===== Ø¥Ø¹Ø¯Ø§Ø¯ Docker =====
        function setupDocker() {
            try {
                debugLog('ğŸ³ Ø¬Ø§Ø±ÙŠ ØªÙ‡ÙŠØ¦Ø© Docker...', 'info');
                showLoadingMessage('Ø¬Ø§Ø±ÙŠ ØªÙ‡ÙŠØ¦Ø© Ø­Ø§ÙˆÙŠØ§Øª Docker...');
                
                dockerWorker = createDockerWorker();
                
                dockerWorker.onmessage = (e) => {
                    if (e.data.type === 'output') {
                        term.write(e.data.content);
                    } else if (e.data.type === 'status') {
                        updateStatus(e.data.message);
                    } else if (e.data.type === 'error') {
                        debugLog(`âŒ ${e.data.message}`, 'error');
                    } else if (e.data.type === 'docker-ready') {
                        debugLog('âœ… Docker Ø¬Ø§Ù‡Ø² Ù„ØªØ´ØºÙŠÙ„ macOS!', 'success');
                        isSystemReady = true;
                        hideLoadingOverlay();
                        fitAddon.fit();
                        term.focus();
                        term.writeln('\x1b[32mâœ… Ø§Ù„Ù†Ø¸Ø§Ù… Ø¬Ø§Ù‡Ø² Ù„Ù„ØªØ´ØºÙŠÙ„!\x1b[0m');
                        term.writeln('\x1b[33mğŸ“ Ø§ÙƒØªØ¨ "start-macos" Ù„Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ macOS\x1b[0m');
                    } else if (e.data.type === 'python-installed') {
                        term.writeln('\x1b[32mâœ… ØªÙ… ØªØ«Ø¨ÙŠØª Python Ø¨Ù†Ø¬Ø§Ø­!\x1b[0m');
                    } else if (e.data.type === 'git-installed') {
                        term.writeln('\x1b[32mâœ… ØªÙ… ØªØ«Ø¨ÙŠØª Git Ø¨Ù†Ø¬Ø§Ø­!\x1b[0m');
                    }
                };
                
                dockerWorker.postMessage({
                    type: 'init',
                    config: {
                        volumes: {
                            '/macos_data': 'macos_data',
                            '/docker_config': 'docker_config'
                        }
                    }
                });
                
                return true;
            } catch (error) {
                debugLog(`âŒ ÙØ´Ù„ Ø¥Ø¹Ø¯Ø§Ø¯ Docker: ${error.message}`, 'error');
                return false;
            }
        }

        // ===== ØªØ´ØºÙŠÙ„ macOS =====
        function startMacOS() {
            const dockerCommand = {
                image: 'sickcodes/docker-osx:auto',
                command: 'run -it',
                options: {
                    devices: ['/dev/kvm'],
                    ports: {'10022': '50922'},
                    volumes: {
                        '/tmp/.X11-unix': '/tmp/.X11-unix',
                        '/macos_data': '/data',
                        '/macos_data/linux-kernel.iso': '/kernel.iso'
                    },
                    env: {
                        GENERATE_UNIQUE: 'true',
                        RAM_SIZE: CONFIG.RAM_SIZE.toString(),
                        CPU_CORES: CONFIG.CPU_CORES.toString(),
                        OSX_VERSION: 'ventura',
                        BOOT_ARGS: 'keepsyms=1 -v',
                        KERNEL_IMAGE: '/kernel.iso',
                        BOOT_LOADER: 'grub',
                        KERNEL_PARAMS: 'console=ttyS0 root=/dev/vda1'
                    },
                    postRun: [
                        'chmod +x /install_essentials.sh',
                        '/install_essentials.sh'
                    ]
                }
            };
            
            dockerWorker.postMessage({
                type: 'run',
                container: dockerCommand
            });
        }

        // ===== ØªØ«Ø¨ÙŠØª Python Ùˆ Git =====
        async function installEssentials() {
            try {
                debugLog('ğŸ Ø¬Ø§Ø±ÙŠ ØªØ«Ø¨ÙŠØª Python Ùˆ Git...', 'info');
                
                const installScript = `#!/bin/bash

echo "Ø¬Ø§Ø±ÙŠ Ø§Ù„ØªØ«Ø¨ÙŠØªØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø§Ù†ØªØ¸Ø§Ø±..."

# ØªØ«Ø¨ÙŠØª Xcode Command Line Tools
xcode-select --install

# ØªØ«Ø¨ÙŠØª Homebrew
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ù…Ø³Ø§Ø±Ø§Øª
echo 'export PATH="/opt/homebrew/bin:$PATH"' >> ~/.zshrc
source ~/.zshrc

# ØªØ«Ø¨ÙŠØª Python Ùˆ Git
brew install python@3.11 git

# ØªØ«Ø¨ÙŠØª Ø£Ø¯ÙˆØ§Øª Ø¥Ø¶Ø§ÙÙŠØ©
brew install wget curl htop neofetch

# Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø¥ØµØ¯Ø§Ø±Ø§Øª
echo "Python: \$(python3 --version)"
echo "Git: \$(git --version)"
echo "Wget: \$(wget --version | head -n1)"
echo "Curl: \$(curl --version | head -n1)"

echo "âœ… ØªÙ… ØªØ«Ø¨ÙŠØª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ§Øª Ø¨Ù†Ø¬Ø§Ø­!"
`;
                const root = await driveHandle.resolve();
                const fileHandle = await root.getFileHandle('install_essentials.sh', { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(installScript);
                await writable.close();
                
                debugLog('âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø³ÙƒØ±ÙŠØ¨Øª Ø§Ù„ØªØ«Ø¨ÙŠØª!', 'success');
                return true;
            } catch (error) {
                debugLog(`âŒ Ø®Ø·Ø£ ÙÙŠ ØªØ«Ø¨ÙŠØª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ§Øª: ${error.message}`, 'error');
                return false;
            }
        }

        // ===== Ù†Ø¸Ø§Ù… Ø§Ù„Ø­ÙØ¸ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ =====
        function setupAutoSave() {
            setInterval(() => {
                term.write('\x1b[33m[Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø­ÙØ¸ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ...]\x1b[0m');
                kvmWorker.postMessage({type: 'snapshot', name: `autosave-${Date.now()}`});
                saveSessionState();
            }, CONFIG.AUTO_SAVE_INTERVAL);
        }

        // ===== Ø§Ø³ØªÙ…Ø±Ø§Ø±ÙŠØ© Ø§Ù„Ø¬Ù„Ø³Ø© =====
        function saveSessionState() {
            const state = {
                timestamp: new Date().toISOString(),
                ramUsage: document.getElementById('resource-monitor')?.innerText || 'N/A'
            };
            localStorage.setItem(CONFIG.PERSISTENCE_KEY, JSON.stringify(state));
        }

        function restoreSessionState() {
            const savedState = localStorage.getItem(CONFIG.PERSISTENCE_KEY);
            if (savedState) {
                const state = JSON.parse(savedState);
                term.writeln(`\x1b[33mâ±ï¸ ØªÙ… Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø¬Ù„Ø³Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©: ${state.timestamp}\x1b[0m`);
                term.writeln(`\x1b[33mğŸ’¾ Ø­Ø§Ù„Ø© Ø§Ù„Ù…ÙˆØ§Ø±Ø¯: ${state.ramUsage}\x1b[0m`);
            }
        }

        // ===== Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ù…ÙˆØ§Ø±Ø¯ =====
        function startResourceMonitoring() {
            setInterval(() => {
                if (kvmWorker) {
                    kvmWorker.postMessage({type: 'get-resources'});
                }
            }, 5000);
        }

        function updateResources(ram, cpu) {
            const ramGB = (ram / 1024).toFixed(1);
            document.getElementById('resource-monitor').innerText = 
                `RAM: ${ramGB}GB/4GB | CPU: ${cpu}%`;
        }

        // ===== Ø£ÙˆØ§Ù…Ø± Ø§Ù„ØªÙŠØ±Ù…ÙŠÙ†Ø§Ù„ =====
        function setupTerminalCommands() {
            term.onData(data => {
                const input = data.trim();
                
                if (data === '\x0C') { // Ctrl+L
                    term.clear();
                } else if (input === 'help') {
                    toggleCommandList();
                } else if (input === 'start-macos') {
                    startMacOS();
                } else if (input === 'stop-macos') {
                    dockerWorker.postMessage({type: 'stop'});
                } else if (input === 'restart-macos') {
                    dockerWorker.postMessage({type: 'restart'});
                } else if (input.startsWith('set-ram')) {
                    const ram = parseInt(input.split(' ')[1]);
                    if (ram >= 2048 && ram <= 4096) {
                        kvmWorker.postMessage({type: 'set-ram', ram});
                    } else {
                        term.writeln('\x1b[31mâŒ Ø®Ø·Ø£: Ø­Ø¬Ù… Ø§Ù„Ø°Ø§ÙƒØ±Ø© ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø¨ÙŠÙ† 2048 Ùˆ 4096\x1b[0m');
                    }
                } else if (input === 'install-python-git') {
                    installEssentials();
                } else if (input === 'run-install-script') {
                    dockerWorker.postMessage({
                        type: 'run-command',
                        command: '/install_essentials.sh'
                    });
                } else if (input === 'create-snapshot') {
                    const name = `snapshot-${Date.now()}`;
                    kvmWorker.postMessage({type: 'snapshot', name});
                } else if (input === 'restore-snapshot') {
                    kvmWorker.postMessage({type: 'restore', name: 'latest'});
                } else if (input === 'list-snapshots') {
                    kvmWorker.postMessage({type: 'list-snapshots'});
                } else if (input.startsWith('set-resolution')) {
                    const res = input.split(' ')[1];
                    dockerWorker.postMessage({
                        type: 'run-command',
                        command: `sudo nvram resolution="${res}"`
                    });
                } else if (input === 'neofetch') {
                    dockerWorker.postMessage({
                        type: 'run-command',
                        command: 'neofetch'
                    });
                } else if (input === 'htop') {
                    dockerWorker.postMessage({
                        type: 'run-command',
                        command: 'htop'
                    });
                } else if (input === 'python3') {
                    dockerWorker.postMessage({
                        type: 'run-command',
                        command: 'python3'
                    });
                } else if (input === 'git') {
                    dockerWorker.postMessage({
                        type: 'run-command',
                        command: 'git --help'
                    });
                } else if (input) {
                    dockerWorker.postMessage({
                        type: 'input',
                        data: data
                    });
                }
            });
        }

        // ===== Ø¨Ø¯Ø¡ Ø§Ù„Ù†Ø¸Ø§Ù… =====
        async function initializeSystem() {
            try {
                // Ø¥Ø¹Ø¯Ø§Ø¯ Ù…Ø³Ø§Ø­Ø© Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ù…ÙˆØ§Ø±Ø¯
                const resourceMonitor = document.createElement('div');
                resourceMonitor.id = 'resource-monitor';
                resourceMonitor.style.position = 'absolute';
                resourceMonitor.style.top = '5px';
                resourceMonitor.style.right = '10px';
                resourceMonitor.style.color = '#ff0';
                document.getElementById('status-bar').appendChild(resourceMonitor);
                
                // Ø¥Ø¹Ø¯Ø§Ø¯ Ø²Ø± Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©
                document.getElementById('help-btn').addEventListener('click', toggleCommandList);
                
                // Ø§Ø³ØªØ¹Ø§Ø¯Ø© Ø§Ù„Ø¬Ù„Ø³Ø© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø©
                restoreSessionState();
                
                // Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø¬ÙˆØ¬Ù„ Ø¯Ø±Ø§ÙŠÙ
                if (await connectGoogleDrive()) {
                    // ØªØ­Ù…ÙŠÙ„ Ù†ÙˆØ§Ø© Linux
                    if (await loadLinuxKernel()) {
                        // ØªØ«Ø¨ÙŠØª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ§Øª
                        await installEssentials();
                        
                        // ØªÙ‡ÙŠØ¦Ø© KVM
                        if (await setupKVM()) {
                            // Ø¥Ø¹Ø¯Ø§Ø¯ Ø£ÙˆØ§Ù…Ø± Ø§Ù„ØªÙŠØ±Ù…ÙŠÙ†Ø§Ù„
                            setupTerminalCommands();
                            
                            // Ø¨Ø¯Ø¡ Ù…Ø±Ø§Ù‚Ø¨Ø© Ø§Ù„Ù…ÙˆØ§Ø±Ø¯
                            startResourceMonitoring();
                            
                            // ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø­ÙØ¸ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ
                            setupAutoSave();
                            
                            // Ø¥Ø¹Ø¯Ø§Ø¯ Ù„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­
                            setupIOSKeyboard();
                        }
                    }
                }
            } catch (error) {
                debugLog(`âŒ Ø®Ø·Ø£ ÙØ§Ø¯Ø­: ${error.message}`, 'error');
                showLoadingMessage(`ÙØ´Ù„ Ø§Ù„ØªÙ‡ÙŠØ¦Ø©: ${error.message}`);
            }
        }

        // Ø¨Ø¯Ø¡ Ø§Ù„ØªØ´ØºÙŠÙ„ Ø¹Ù†Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø©
        window.addEventListener('load', initializeSystem);
        
        // Ø¶Ø¨Ø· Ø­Ø¬Ù… Ø§Ù„ØªÙŠØ±Ù…ÙŠÙ†Ø§Ù„ Ø¹Ù†Ø¯ ØªØºÙŠÙŠØ± Ø­Ø¬Ù… Ø§Ù„Ù†Ø§ÙØ°Ø©
        window.addEventListener('resize', () => {
            if (isSystemReady) fitAddon.fit();
        });
    </script>
</body>
</html>
